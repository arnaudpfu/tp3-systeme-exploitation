# Compte rendu TP3 de système

## Question 1

J’ai simplement fais un `sem_post` à la fin de p1 et un `sem_wait`au début de p2.

![Untitled](images/Untitled.png)

## Question 2

Solution qui ne fonctionne pas. Les deux sémaphores sont initialisés à 0. Donc les deux sémaphores sont bloquant comme on les libères seulement après les avoir bloqués. Process-one bloque sem2 et process-two bloque sem1. On a donc un inter-blocage.

![Untitled](images/Untitled%201.png)

J’ai simplement interverti l’orde de `sem_wait` et `sem_post` dans le processus 1 pour la solution proposée (cela fonctionnerait aussi si on intervertissait ces deux commandes dans le processus 2).

![Untitled](images/Untitled%202.png)

## Question 3 : Exclusion mutuelle

![Untitled](images/Untitled%203.png)

Le pseudo code ci-dessus assure que seul un thread peut accéder à la mémoire partagée pointée par la variable `count` en même temps car le sémaphore `mutex` (initialisé à 1 donc pas encore bloquant) devient bloquant à l’entrée de chaque thread (en passant de 1 à 0). De plus, il se débloque uniquement à la sortie de chaque thread donc l’exclusion mutuelle est garantie.

## Question 4 : Un Producteur - Un Consommateur

Le tampon est implémenté en utilisant un tableau et trois variables globales : **`count`** qui représente le nombre d'éléments dans le tampon, **`in`** qui représente l'index du prochain emplacement libre dans le tampon, et **`out`** qui représente l'index du prochain élément à consommer dans le tampon.

Le producteur utilise un mutex pour éviter les accès concurrents au tampon. Si le tampon est plein, le producteur attend en utilisant une variable conditionnelle **`empty`** qui est signalée par le consommateur lorsqu'il retire un élément du tampon. Lorsqu'un emplacement libre est disponible dans le tampon, le producteur y place l'élément produit, met à jour les variables **`in`** et **`count`**, et signale la variable conditionnelle **`full`** pour informer le consommateur qu'un élément est disponible dans le tampon.

## Question 5: Multi-producteur - Multi-consommateur

Dans le cas du multi-producteur/consommateur, nous avons besoin d'une structure de données pour permettre la communication et la synchronisation entre les producteurs et les consommateurs. La file d'attente garantit ici l'ordre d'arrivée des éléments et offre un mécanisme simple et efficace pour ajouter des éléments (enqueuing) et les retirer (dequeuing).

Les fonctions **`Deposer()`** et **`Retirer()`** vont donc simplement consister à enqueue/dequeue les messages stockés, exemple : 

```c
// Fonction pour déposer un élément dans la file d'attente (enqueuing)
void Deposer(struct Queue* queue, int item)
{
    enqueue(queue, item);
}

// Fonction pour retirer un élément de la file d'attente (dequeuing)
int Retirer(struct Queue* queue)
{
    return dequeue(queue);
}
```